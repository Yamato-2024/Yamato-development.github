---
date: 2025-10-03
---


![[fe433edd32cdd4293f2521e08ad5676c.jpg|575]]
# 一、作用
1. 异常是用来查询bug的关键参考信息。
2. 异常可以作为方法内部的一种特殊的返回值，以通知调用者底层的执行情况。

# 二、处理方式
#### 1.JVM默认的处理模式
- 将异常名、原因及位置等信息输出在控制台，后面代码不运行。
#### 2.自己处理（抛出）    ==告诉调用者出错了==
- 目的：代码异常时，让程序继续运行。
```java  
public class Test {
    // 数组声明：这是一个字段（Field），可以直接放在类体中
    int[] arr = {1, 2, 3, 4, 5, 6};
    // main 方法：程序的执行入口
    public static void main(String[] args) {
        // 要访问非静态字段 arr，需要先创建 Test 类的实例
        Test test = new Test();
        // 可执行的逻辑（try-catch 和打印）必须放在方法内部
        try {  
            // 可能出现异常的代码；  
            System.out.println(test.arr[10]); // 通过实例访问 arr  
            //此处出现了异常，程序就会在这里创建一个`ArrayIndexOutOfBoundsException`对象
			//new ArrayIndexOutOfBoundsException ();
			// 拿着这个对象到 catch 的小括号中对比，看括号中的变量是否可以接收这个对象
			// 如果能被接收，就表示该异常就被捕获（抓住），执行 catch 里面对应的代码
			// 当 catch 里面所有的代码执行完毕，继续执行 try...catch 体系下面的其他代码
        } catch (ArrayIndexOutOfBoundsException e) {  
            // 异常处理  
            System.out.println("索引越界了");  
        }  
        System.out.println("看看我执行了吗？"); 
    } 
}
```

```
- q1：如果try中遇到多个问题，怎么执行？
- a1：写多个catch与其对应 / 在catch中使用"|"字符写多个错误对象。
- q2：如果try中的异常没有被捕获，怎么执行？
- a2：相当于try...catch...白写了，最终还是交给虚拟机处理。
- q3：如果try中遇到了问题，try中后续代码还会运行吗。
- a3：不会了。
```


==注意：如果需要捕获多个异常，且异常中存在父子关系的，父亲要写在子类下方==

- Throwable 的成员方法

| 方法名称                              | 说明                                                                              |
| --------------------------------- | ------------------------------------------------------------------------------- |
| public String getMessage()        | 返回此throwable的详细消息字符串                                                            |
| public String toString()          | 返回此可抛出的简短描述                                                                     |
| ==public void printStackTrace()== | 在底层是利用`System.err.println`进行输出，<br>把异常的错误信息以红色字体输出在控制台。<br>细节：仅仅是打印信息，不会停止程序运行。 |
```java
public class Test{
	public static void main(String[] args) {
		int[] arr = {1, 2, 3, 4, 5, 6}; 
		try { 
			System.out.println(arr[10]); 
		} catch (ArrayIndexOutOfBoundsException e) { 
		/* String message = e.getMessage(); 
		System.out.println(message);//Index 10 out of bounds for length 6*/ 
			String str = e.toString();
			System.out.println(str);//java.lang.ArrayIndexOutOfBoundsException:  Index 10 out of bounds for length 6 
		e.printStackTrace(); 
	} 
	System.out.println("看看我执行了吗？");
	}
}
```

#### 3. 抛出异常    ==不让程序停止==
##### thorws
- 写在方法定义处，表示声明一个异常，告诉调用者，使用本方法可能会有哪些异常。
- <u>编译时异常必须写</u>
- <u>运行时异常可不写</u>
```java
public void 方法()throws 异常名1,异常名2...{
}
```
##### thorw
- 写在方法内，结束方法，手动抛出异常对象，交给调用者，方法中下面的代码不再执行。
```java
publc void 方法(){
	throw new NullPointerException();
}
```


# 三、自定义异常
1. 意义：让控制台的报错信息更加见名知意。
2. 步骤：自定义异常类 ---> 写继承关系 ---> 空参构造 ---> 带参构造
```java
public class NameFormatException extends RuntimeException{  
    //技巧：   NameFormat：当前异常的名字，表示姓名格式化问题。  
    //      Exception：表示当前类是一个异常类。  
    public NameFormatException() {  
    }  
    public NameFormatException(String message) {  
        super(message);  
    }  
}
```
3. 技巧：
	- NameFormat：当前异常的名字，表示姓名格式化问题。
	- Exception：表示当前类是一个异常类。
```java
public void setName(String name) {  
    if(name.length() < 3 || name.length() > 10){  
        throw new NameFormatException("姓名长度有误");  
    }  
    this.name = name;  
}
```

```java
public static void main(String[] args) {  
    Scanner sc = new Scanner(System.in);  
    GirlFriend gf = new GirlFriend();  
    while (true) {  
        try {  
            System.out.println("请输入对象的名字和年龄：");  
            String name = sc.nextLine();  
            int age = sc.nextInt();  
            gf.setName(name);  
            gf.setAge(age);  
            break;  
        } catch (NumberFormatException e) {  
            e.printStackTrace();  
        } catch (RuntimeException e){  
            e.printStackTrace();  
            //continue;  
        }  
    }  
    System.out.println(gf.getName() + " " + gf.getAge());  
}
```
